# Week 10-11 — CloudFormation
## Live-Stream Cloudformation (CFN) Basics

During the live stream, we went through some general ideas on how you can organize your CloudFormation (CFN) template. You could for example have your networking infrastructure in one CFN template and application in another. It is often easier to make smaller sections and then later combine them if you have to. Otherwise, it’s difficult to know what’s going on if they fail. You also lose some flexibility if you combine the stacks together. 

You have to consider how your different stacks are going to be connected. For example, our cluster is probably going to reference the networking stack. The database might be orphaned or connected to networking. 

In terms of debugging we learn that, the easiest way to debug CFN is by using CloudTrail. 

General structure of the CFN template for each stack is that there are parameters, which can be referred to in other parts of the template to avoid having to hard-code those values. Below that you list all the resources you want to create with the CFN template. At the bottom you can list outputs, which can be imported into other stacks. These are cross-stack references, which will be heavily used in our CFN stacks. 

## Implement CFN Networking Layer

In terms of networking, going through the core components is very important. It would be possibly to use the default VPC for this project, but the decision was made to create a new VPC using CFN.

First a networking folder was created in the CFN folder. A ``template.yaml`` was created in the folder. Also a bin script was added for deploying the networking stack. Added also Readme.md that has instructions to create an S3 bucket for CFN artifacts. This bucket was created directly in the AWS console instead of CFN. 

Next it was necessary to choose the CIRD-block: how many containers we need. For our use-case /16 is good. If you have a container that fails in one AZ, you would usually want to have another container in a different region. This would require more ip-addresses. 

Added InternetGateway to the CFN template. It’s not automatically attached, so AttachIGW had to be separately added to the template. 

A route table and two routes were added to the template - one route to internet gateway and another to local. This turned out to be the wrong decision, as  the route to local is created automatically and this is why our template failed. So we actually have to set up only one route.

Added subnets. We have 3 public subnets and we don’t currently need private subnets but we create 3 in case we are going to need it later for example for our database. Although it will make it harder to connect to our database, it is best practice. 

Added availability zones as parameters to the CFN template, so that we don’t have to write those every time for each subnet, but refer to them by using ``!Ref``.

Deploying the CFN template creates a ChangeSet in the AWS console. We have to manually go and open the ChangeSet, which lists all the resources that will be created with that stack. The change set can then be manually executed through the console. 

## Implement CFN Networking Layer (Diagram)

The diagram shows the three public subnets that are used as well as three private subnets that are currently not used but were created for possible future use. The Fargate cluster spans accross the three public subnets:

![networking diagram](assets/networking_diagram.png)

## Implement CFN Cluster Layer

Similarly as the networking stack, this stack also has a ``template.yaml`` file and a cluster-deploy bash script. 

Added NetworkingStack as a parameter so that it's resources can be referred to.

Added the same resources to the template that were created in the previous stages of the project: Fargate Cluster, Application Load Balancer, Listeners, Security Groups and Target Groups.

The ACM certificate, could also be created through CloudFormation, however we will instead refer to the CertificateARN we created earlier. 

The fact that we created our own VPC, created some extra challenges as our security groups were not fist correctly within the VPC. It would have been more straightforward to use the default one and it is easier, but it was good practise.

## Implement CFN Toml

As we need to use the previously created Certificate ARN, we need a way to import it. You could also hardcode it, but a better solution is to have a toml-file to import it that value. For this purpose we used cfn-toml, which is a Toml configuration for bash scripts using CloudFormation. 

Started by running ``gem install cfn-toml`` and added the command also to Gitpod.yml. Next added ``config.toml`` file for aws/cluster. Then the cluster-deploy was modified to use the toml file.

# Implement CFN Cluster Layer (Diagram)

The below diagram shows other parts of the cluster layer, apart from the Fargate cluster itself:

[cluster_diagram](assets/cluster_diagram.png)

## Implement CFN Database Layer (RDS)
## Implement Service and Database (Diagram)
## Implement DynamoDB using SAM
## Implement DynamoDB (Diagram)
## Implement CI/CD
## CI/CD (Diagram)
## Implement CFN Static Website Hosting for Frontend
